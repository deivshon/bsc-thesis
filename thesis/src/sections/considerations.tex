\chapter{Considerations}
This chapter aims to highlight advantages and disadvantages of using Elm, analyzing its choices and comparing them to those of other languages and frameworks

\section{Elm Tooling}
Elm offers a single binary that includes a few core features:
\begin{itemize}
    \item Initializing an Elm project
    \item Compiling an Elm project
    \item Installing Elm packages
\end{itemize}

While said Elm binary works well, other important features are not offered:
\begin{itemize}
    \item \textbf{Formatter}\\Although an official Elm style guide exists \cite{noauthor_style_nodate}, the Elm binary does not include a formatter (nor does any official Elm tool), and the de-facto standard is \texttt{elm-format}, a third party tool \cite{vonderhaar_avh4elm-format_2024}
    \item \textbf{Linter}\\Many anti-patterns and other problems in code can't be encoded into the type system. Even languages with complex semantics often include a linter, like Rust's Clippy \cite{noauthor_rust-langrust-clippy_2024}, to provide the developer with stricter guidelines and allow them to avoid common footguns
    \item \textbf{Language Server Protocol}\\When working with a programming language today a tightly integrated experience within the editor is expected, for which an LSP is needed. The de-facto standard LSP implementation for Elm is third party. \cite{noauthor_elm-toolingelm-language-server_nodate}
\end{itemize}

\subsection{Bundling}
% Mention that there is no obvious way to bundle ports with elm's tooling and the user is left to whatever solution they choose
A basic Elm program initialized using \texttt{Browser.sandbox} produces a single \texttt{index.html} file when transpiled. This file includes a script tag containing all the necessary code Elm needs to run properly.\\

This works well for extremely simple scenarios, but if you need a port, multiple pages or even just adding different link tags to the resulting HTML, it becomes inadequate. In such common cases the \texttt{output} option can be used during compilation: it allows to specify an output file path that will contain only the transpiled JavaScript code, so that it can be independently included in a script tag. This is a good modular approach, but it creates another issue to be solved: something needs to bundle all of the needed assets.\\

This is normally done by a build tool such as Vite. Many frameworks today offer:
\begin{itemize}
    \item A plugin for their build tool of choice
    \item Another tool such as a CLI to quickly get started building a production-grade application, which typically includes out of the box support for a development server and production builds using built-in commands instead of custom scripts
\end{itemize}
None of this is currently offered by Elm directly. An unofficial Vite plugin exists \cite{hamasaki_hmskvite-plugin-elm_2024}, but no CLI or similar tool exist for getting started with a working configuration.\\

The most complete Elm development experience is offered by the \texttt{elm-pages} framework, which also allows to create full-stack applications with API routes, server side rendering and hydration. \cite{noauthor_what_nodate}

\section{(Lack of) Components}
What sets Elm apart from the most popular frontend solutions is the fact that it is not component-based. Rather than seeing the UI as many objects interacting with each other, Elm's computed UIs are the output of a pure function that has the current \texttt{Model} instance as its input. Therefore, there is no concept of state that is local to any entity in Elm, all state is centralized, and the only way it can be changed is by returning a different \texttt{Model} instance from the main \texttt{update} function.

This has significant benefits:
\begin{itemize}
    \item State changes in a more predictable way, given \texttt{update} is the only function where this happens
    \item The data flow is predictable: the TEA fully adopts a MVU (Model View Update) model, and the basic cycle is simple to understand and reason about
\end{itemize}

The most significant downside is scalability. Elm works fairly well for small to medium sized applications, but at a certain size the centralized state approach becomes a significant overhead, the size of the model and the different messages increase significantly. While composition and modularization can help, component-based frameworks usually avoid this problem completely since, unlinke in Elm, local state is allowed.\\

The login and signup from the simple social network application are an interesting example. There is no real reason any entity within the Elm application needs to know about the username and password the user inputs in the respective fields, these just need to be tracked somewhere and communicated at some point so that the related API call can fire.\\

While in the example application adding the login and signup related state in the global model did not cause issues, if the application contains many independent parts each with their own piece of state which could have been local, then the cumulated noise can become significant. This kind of application with strong interactive features is also one where Elm would generally be considered a good choice.

\section{Limits of JavaScript interoperability}
% No willingness to create tools that even help with interoperability, ports code generation comes to mind for instance, while canonically you have to create the .d.ts file yourself if you want typesafety (which you don't have unless you specify everything as their T | undefined)

As mentioned previously, Elm has opted for a limited interoperability strategy with JavaScript, providing no way of calling JavaScript function directly. This is needed to ensure the stability and robustness of the Elm runtime, since foreign functions can't be trusted to have the same strong guarantee of not crashing that Elm provides internally. Ports are the most popular way to interoperate with JavaScript, although Web Components can also be used.\\

Using ports instead of traditional FFI can add significant overhead in some cases. For instance, if there is existing JavaScript code that performs synchronous operations, with FFI the related function could simply be called and the result would be directly available for use.\\
With ports, two of them would be needed, one for receiving the input from and the other for sending the output to the Elm runtime. Because of the nature of how ports are handled in Elm the operation is now forced to be handled asynchronously: first a message is sent requesting the operation with some inputs, and then the result is received through a message.

\section{Final thoughts}
