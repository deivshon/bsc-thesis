\chapter{Considerations}
This chapter aims to highlight advantages and disadvantages of using Elm, analyzing its choices and comparing them to those of other languages and frameworks

\section{Elm Tooling}
Elm offers a single binary that includes a few core features:
\begin{itemize}
    \item Initializing an Elm project
    \item Compiling an Elm project
    \item Installing Elm packages
\end{itemize}

While said Elm binary works well, other important features are not offered:
\begin{itemize}
    \item \textbf{Formatter}\\Although an official Elm style guide exists \cite{noauthor_style_nodate}, the Elm binary does not include a formatter (nor does any official Elm tool), and the de-facto standard is \texttt{elm-format}, a third party tool \cite{vonderhaar_avh4elm-format_2024}
    \item \textbf{Linter}\\Many anti-patterns and other problems in code can't be encoded into the type system. Even languages with complex semantics often include a linter, like Rust's Clippy \cite{noauthor_rust-langrust-clippy_2024}, to provide the developer with stricter guidelines and allow them to avoid common footguns
    \item \textbf{Language Server Protocol}\\When working with a programming language today a tightly integrated experience within the editor is expected, for which an LSP is needed. The de-facto standard LSP implementation for Elm is third party. \cite{noauthor_elm-toolingelm-language-server_nodate}
\end{itemize}

\subsection{Bundling}
% Mention that there is no obvious way to bundle ports with elm's tooling and the user is left to whatever solution they choose
A basic Elm program initialized using \texttt{Browser.sandbox} produces a single \texttt{index.html} file when transpiled. This file includes a script tag containing all the necessary code Elm needs to run properly.\\

This works well for extremely simple scenarios, but if you need a port, multiple pages or even just adding different link tags to the resulting HTML, it becomes inadequate. In such common cases the \texttt{output} option in the \texttt{elm} binary is needed: it allows to specify an output file path that will contain only the transpiled JavaScript code, so that it can be independently included in a script tag. This is a good modular approach, but it creates another issue to be solved: something needs to bundle all of the needed assets.\\

This is normally done by a build tool such as Vite. Many frameworks today offer:
\begin{itemize}
    \item A plugin for their build tool of choice
    \item Another tool to quickly get started building a production-grade application, which typically includes out of the box support for a development server and production builds using built-in commands instead of custom scripts
\end{itemize}
None of this is currently offered by Elm directly. An unofficial Vite plugin exists \cite{hamasaki_hmskvite-plugin-elm_2024}, but no CLI or similar tool exist for getting started with a working configuration.\\

The most complete Elm development experience is offered by the \texttt{elm-pages} framework, which also allows to create full-stack applications with API routes, server side rendering and hydration. \cite{noauthor_what_nodate}

\section{(Lack of) Components}
\subsection{Elm's approach}
% Mention centralized state handling overhead
% Mention the whole components debate, refer to granular loaders and the login component and state on URLs change, all stuff that emerges naturally in framework-based solutions. Mention the fact that Elm makes you think about all state within your application in your Main.elm vs other frameworks you can have local state. Mention nested TEA as an Elm antipattern
\subsection{Nested TEA as an anti-pattern}
% Html.map etc
\section{Limits of JavaScript interoperability}
% No willingness to create tools that even help with interoperability, ports code generation comes to mind for instance, while canonically you have to create the .d.ts file yourself if you want typesafety (which you don't have unless you specify everything as their T | undefined)
\section{Final thoughts}
