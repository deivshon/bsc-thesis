\chapter{Introduction}
\setcounter{page}{1}

\section{The frontend landscape}
% Functional languages for frontend, mention purescript/rescript
JavaScript is the web's scripting language, and while some forms of interactivity such as form submissions are possible without it, less than 2\% of websistes doesn't include any \cite{noauthor_usage_nodate}. JavaScript is an imperative, weakly and dynamically typed programming language. While it can be used directly, today it is also a transpilation target of a plethora of programming languages \cite{noauthor_list_nodate}.\\

Most modern websites are created with frameworks that facilitate the creation of dynamic UIs by letting the developer write declarative code and handling reconciliation between state and the DOM internally. While frameworks solve a class of problems, they can't solve JavaScript's: not having a static type system makes it easy for subtle bugs to go undetected, and makes refactoring existing code hard to complete without introducing regressions.\\

For this reason, many of the languages that transpile to JavaScript include static type systems. TypeScript is the most successful one \cite{noauthor_most_nodate}, it seeks to add only a thin layer on top of plain JavaScript that allows for a structural type system to be used, and provides seamless interoperation. Said type system is not sound, and making it sound is not a goal of the language \cite{noauthor_typescript_nodate}, which also includes escape hatches such as type assertions that when abused have the potential to cause runtime errors.

Other languages such as PureScript, ReScript and Elm take a different approach, abstracting more from plain JavaScript in order to not be bound by its inherent limitations.

\section{Elm}
Elm is a purely functional programming language that transpiles to JavaScript. It aims to eliminate all possible runtime errors and let developers write declarative code within a model-view-update framework, known as The Elm Architecture.

\subsection{Stated design goals}
% No runtime errors, even at the cost of limited interoperability

\subsubsection{No runtime errors}
If some Elm code compiles and has been type checked, it must be guaranteed to not crash. This is achieved through its strong static type system and limited interoperability: unlike in similar languages, it's been restricted to message passing only, since calling foreign functions could allow malformed data to sneak into the Elm runtime.

\subsubsection{Predictability}
Side effects are a significant source of impredictability. Being a purely functional language, the developer knows when they call a function in Elm it's always a pure function, which means that no side effects can happen. Data can only be transformed and, if needed, returned to the caller.

\subsubsection{Simplicity}
Elm is meant to be easy to learn and use. This is the reason the language itself is not as comprehensive as some of its purely functional competitors, not providing advanced features like higher-kinded types and type classes.

\subsection{Language features}
% ADTs, pattern matching, strong inference
\subsection{The Elm Architecture (TEA)}
% Mention impossibility of tying messages with a particular state, which often result in boilerplate (e.g. what do you do if you get a message that prompts you to fetch stuff but you don't have a token loaded? You need to handle that case for all messages if you have some token in your state. Solution is to pass the token in the message but this means you have to drill the token down to all components that use it)