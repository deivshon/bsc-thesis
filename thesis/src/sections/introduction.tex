\chapter{Introduction}
\setcounter{page}{1}

\section{The frontend landscape}
% Functional languages for frontend, mention purescript/rescript
JavaScript is the web's scripting language, and while some forms of interactivity such as form submissions are possible without it, less than 2\% of websistes doesn't include any \cite{noauthor_usage_nodate}. JavaScript is an imperative, weakly and dynamically typed programming language. While it can be used directly, today it is also a transpilation target of a plethora of programming languages \cite{noauthor_list_nodate}.\\

Most modern websites are created with frameworks that facilitate the creation of dynamic UIs by letting the developer write declarative code and handling reconciliation between state and the DOM internally. While frameworks solve a class of problems, they can't solve JavaScript's: not having a static type system makes it easy for subtle bugs to go undetected, and makes refactoring existing code hard to complete without introducing regressions.\\

For this reason, many of the languages that transpile to JavaScript include static type systems. TypeScript is the most successful one \cite{noauthor_most_nodate}, it seeks to add only a thin layer on top of plain JavaScript that allows for a structural type system to be used, and provides seamless interoperation. Said type system is not sound, and making it sound is not a goal of the language \cite{noauthor_typescript_nodate}, which also includes escape hatches such as type assertions that when abused have the potential to cause runtime errors.

Other languages such as PureScript, ReScript and Elm take a different approach, abstracting more from plain JavaScript in order to not be bound by its inherent limitations.

\section{Elm}
Elm is a purely functional programming language that transpiles to JavaScript. It aims to eliminate all possible runtime errors and let developers write declarative code within a model-view-update framework, known as The Elm Architecture.

\subsection{Stated design goals}
% No runtime errors, even at the cost of limited interoperability

\subsubsection{No runtime errors}
If some Elm code compiles and has been type checked, it must be guaranteed to not crash. This is achieved through its strong static type system and limited interoperability: unlike in similar languages, it's been restricted to message passing only, since calling foreign functions could allow malformed data to sneak into the Elm runtime.

\subsubsection{Predictability}
Side effects are a significant source of impredictability. Being a purely functional language, the developer knows when they call a function in Elm it's always a pure function, which means that no side effects can happen. Data can only be transformed and, if needed, returned to the caller.

\subsubsection{Simplicity}
Elm is meant to be easy to learn and use. This is the reason the language itself is not as comprehensive as some of its purely functional competitors, not providing advanced features like higher-kinded types and type classes.

\subsection{Language features}
% ADTs, pattern matching, strong inference
\subsubsection{Base types}
Elm provides the following primitive types:
\begin{itemize}
    \item \texttt{String}
    \item \texttt{Int}
    \item \texttt{Float}
    \item \texttt{Bool}
\end{itemize}
The generic \texttt{List} type is also available to create lists of a given type.\\

These types can be used in functions, which in Elm are treated like normal values and can be passed and accepted as parameters.

\subsubsection{Type annotations and inference}
Elm supports type annotations, these help clarify intent and allow readers to understand the function signature by glancing at it instead of relying on IDE tools or needing to go through the implementation:
\begin{minted}{elm}
addToListItems : Int -> List Int -> List Int
addToListItems n ls =
    List.map (\x -> x + n) ls
\end{minted}

Elm's (unofficial) LSP supports a "add type annotation" action. Using it on the unannotated version of the function yields a slightly different result:
\begin{minted}{elm}
addToListItems : number -> List number -> List number
addToListItems n ls =
    List.map (\x -> x + n) ls
\end{minted}
\texttt{number} is neither a \texttt{Float} nor an \texttt{Int} type, instead it's a type that accepts both. When adding a type annotation using the LSP action, Elm adds the same one it computes when performing type inference, which is the widest the implementation can handle.\\
In fact, both \texttt{Float}s and \texttt{Int}s can be passed as the \texttt{addToListItems} function's first parameter, since the \texttt{+} operator in Elm supports both.

\subsubsection{Records}
Elm supports records, single types containing multiple named components. For instance, without records, if we needed to write a function that renders a \textit{Todo} item, we would have to write it like this:
\begin{minted}{elm}
viewTodo id content createdAt updatedAt done =
    ...
\end{minted}
When types in the application domain grow significantly, writing all components separately becomes cumbersome. Instead, we can use a record and accept that, accessing its components with the dot notation:
\begin{minted}{elm}
type alias Todo =
    { id : String
    , content : String
    , createdAt : Int
    , updatedAt : Int
    , done : Bool
    }

viewTodo todo =
    ...

isLongTodo todo =
    String.length todo.content > 50
\end{minted}

\subsubsection{Sum types}
Sum types, commonly referred to within the Elm community  as \textit{custom types} \cite{noauthor_custom_nodate}, are also supported, increasing the type system's expressiveness.\\

They can be used to create regular enums:
\begin{minted}{elm}
type PackageDeliveryStatus
    = InWarehouse
    | InProgress
    | Delivered
\end{minted}

But the types specified may also be associated with an arbitrary number of other types. For instance, we may want to specify when the \texttt{InProgress} and \texttt{Delivered} statuses were reached using a timestamp, and the final delivery address:
\begin{minted}{elm}
type PackageDeliveryStatus
    = InWarehouse
    | InProgress Int
    | Delivered Int String
\end{minted}

An instance of a sum type can be accessed using the \texttt{case/of} pattern matching syntax:
\begin{minted}{elm}
isOutOfWarehouse status =
    case status of
        InWarehouse ->
            False

        _ ->
            True
\end{minted}

The \texttt{\_} character matches all remaining possibilities. Since Elm's pattern matching is required to be exhaustive, leaving any option not covered by a branch results in a compile time error.\\

Pattern matching also allows to access the values inside the type the sum type instance contains:
\begin{minted}{elm}
getStatusString status =
    case status of
        InWarehouse ->
            "In warehouse"

        InProgress ts ->
            "In progress since epoch " ++ String.fromInt ts

        Delivered ts address ->
            "Delivered to "
                ++ address
                ++ " at epoch "
                ++ String.fromInt ts
\end{minted}

\subsubsection{Error handling}
Elm has opted to represent errors as values. A built-in \texttt{Result} type is present
\begin{minted}{elm}
type Result e v
    = Ok v
    | Err e
\end{minted}

Being generic, we can use any type for errors. For instance, we can use another sum type as the \texttt{e} error type, enumerating the possible failure modes. 
\begin{minted}{elm}
type DivisionError
    = DivisionByZero


safeDivide : Float -> Float -> Result DivisionError Float
safeDivide a b =
    if b == 0 then
        Err DivisionByZero

    else
        Ok (a / b)
\end{minted}
This powerful pattern allows to make sure any function caller will not be able to use an invalid result: they must first pattern match on it and, in case of an error, they know exactly what went wrong.\\

Similarly, a \texttt{Maybe} type is available to be used wherever a value may or may not be present:
\begin{minted}{elm}
type Maybe a
    = Just a
    | Nothing

type alias Person =
    { name : String
    , age : Int
    , email : Maybe String
    }
\end{minted}

\subsection{The Elm Architecture (TEA)}
% Mention impossibility of tying messages with a particular state, which often result in boilerplate (e.g. what do you do if you get a message that prompts you to fetch stuff but you don't have a token loaded? You need to handle that case for all messages if you have some token in your state. Solution is to pass the token in the message but this means you have to drill the token down to all components that use it)

The standard way to build interactive web applications with Elm is to use its built-in declarative model-view-update framework, known as The Elm Architecture.

\subsubsection{Model}
An Elm application must have a model that will be used in the view/update cycle. Said model contains the state of the application. For instance, a sample application containing a single checkbox would come with a single \texttt{Bool} as its state, representing whether the checkbox is checked or unchecked:

\begin{minted}{elm}
type alias Model = Bool
\end{minted}

\subsubsection{Update}
In order to change the state when the user performs an action we need to define a message type. This is conventionally named \texttt{Msg} and is usually a sum type. In our simple checkbox example application, we have a single action to associate to a message: the toggling of the checkbox.
\begin{minted}{elm}
type Msg
    = CheckboxClicked
\end{minted}

We should then define a function that takes a message and the current state as parameters and returns the new state. This function is conventionally named \texttt{update}:
\begin{minted}{elm}
update : Msg -> Model -> Model
update msg model =
    case msg of
        CheckboxClicked ->
            not model
\end{minted}

In more complex applications, the update function may not only return the state, but a tuple containing the state and a command to exectue, in turn associated with a message to be handled once it completes:
\begin{minted}{elm}
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    [...]
\end{minted}

\subsubsection{View}
The view function uses the current state to render HTML based on it. Elm comes with a \texttt{Html} package exposing what's necessary to work with all tags, attributes and events.\\
This is a possible view function for the simple checkbox app:
\begin{minted}{elm}
import Html as H
import Html.Attributes exposing (checked, type_)
import Html.Events exposing (onClick)

[...]

view : Model -> H.Html Msg
view model =
    H.div []
        [ H.input
            [ type_ "checkbox"
            , checked model
            , onClick CheckboxClicked
            ]
            []
        , H.span []
            [ H.text
                (if model then
                    "Checked"

                 else
                    "Unchecked"
                )
            ]
        ]
\end{minted}
In the first parameter of a HTML tag all attributes and events related to the node are passed in a list, the second is the list containing its children nodes.\\

A careful look at the \texttt{view} function signature shows the \texttt{H.Html} type is generic and associated to the \texttt{Msg} type. This is because the returned HTML will only cause updates of the \texttt{Msg} type, ensuring the \texttt{update} function can handle them properly.

\subsubsection{Initialization}
An initial state must also be provided, conventionally named \texttt{init}.\\
To bring it all together, update, view and initialization can then be passed to the \texttt{Browser.sandbox} function, which takes care of starting and running the Elm runtime:
\begin{minted}{elm}
init : Model
init =
    False

[...]

main : Program () Model Msg
main =
    Browser.sandbox
        { init = init
        , update = update
        , view = view
        }
\end{minted}

The update function runs every time a message is sent, and the state it returns replaces the current one, at which point the DOM is updated according the what the view function called with this new state returns.

It should be noted that using \texttt{Browser.sandbox} is not the only way to initialize the Elm runtime. In more complex applications \texttt{Browser.application} can be used, which allows for control over URL changes, using a function as the \texttt{init} parameter which can perform computations to decide the initial state, and more.

\subsection{Internals}
A fundamental feature of the vast majority of frontend frameworks today, Elm included, is the automatic synchronization between internal state and the DOM.\\

During runtime, Elm uses a Virtual DOM (often abbreviated to VDOM) to keep track of the current state in respect to the DOM. The Elm VDOM is a lightweight representation of the DOM in JavaScript, which allows fast operations compared to those that would be possible using the real one. \cite{noauthor_htmllazy_nodate}\\

Whenever a new model is returned from them main \texttt{update} function, Elm compares the current VDOM with the next one computed using the new state, so that it can apply the costly real DOM operations only on the elements that actually need it.\\

